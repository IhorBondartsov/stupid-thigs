# Каналы

- Отправка и чтение nil каналов заблокирована навсегда
- После закрытия канала канал будет всегда возвращать пустое значение
- Запись в закрытый канал вызовет панику

Есть два вида каналов буферезированые и небуферезированные


##### Select


```
select {
case <-ch1:
    fmt.Println("Received from ch1")
case <-ch2:
    fmt.Println("Received from ch2")
}
```
- если данные прийдут одновременно в два канала выбор кейса будет рандомным
- если мы хотим отключить один из каналов то просто делаем его nil блокировка навсегда

##### Частые случаи появление data races
  “Don’t communicate by sharing memory; share memory by communicating.”
- совместно используемая переменная
- горутины совместно ждут результато выполнения друг друга

##### Канал в канале
Красивое использование каналов для того что бы синхронизировать работу между ними. или с его помощью сделать подобие мьютекса.

```
type Message struct {
    Message string
    Wait    chan bool
}

messageChannel := make (chan Message)

func sendMessage(msg1 Message){
    messageChannel <- msg1
    msg1.Wait <- true
}
```

