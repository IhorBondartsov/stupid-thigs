package main

import (
	"fmt"
	"time"
)

// Сотрим что будет при закрытии канала в котором есть данные
// Факты: после закрытия канал возращает дефолтные значения
//        запись в закрытый канал вызывает панику
//        до тех пор пока в БУФЕРЕЗИРОВАНОМ канале есть невычитаное значение он считается открытым

func main(){
	// У нас есть канал в который пишут две рутины. После первого чтения закрываем канал.
	c := make(chan int) // канал закроется и данные в канале будут потеряны
	//c := make(chan int, 1) // канал буферезирован и закроется только после вычитывания элемента
	//c := make(chan int, 5) // канал буферезирован и закроется только после вычитывания элемента

	go func(){
		c <- 10
		fmt.Println("10 Done")
	}()
	go func(){
		// для небуферезированого канала может вызвать панику в этом примере
		// я пока что связываю это с тем что рутина не пишет в канал пока нет читателя
		c <- 15
		fmt.Println("15 Done")
	}()

	// Даем две секунды на инициализацию рутин
	time.Sleep(2 * time.Second)

	// Считываем результат
	v, ok := <- c
	fmt.Println(v, ok)

	// Ждем пока запишет вторая рутина и закрываем канал
	time.Sleep(2 * time.Second)
	close(c)

	// канал все еще открыт ждя буферезированого и закрыт для не буф
	v, ok = <- c
	fmt.Println(v, ok)
	// Канал уже закрыт для буф
	v, ok = <- c
	fmt.Println(v, ok)
}